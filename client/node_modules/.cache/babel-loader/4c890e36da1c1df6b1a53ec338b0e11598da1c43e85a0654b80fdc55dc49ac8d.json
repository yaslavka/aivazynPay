{"ast":null,"code":"var utils = require('../../src/utils');\n\n/*\n TraceKit - Cross brower stack traces\n\n This was originally forked from github.com/occ/TraceKit, but has since been\n largely re-written and is now maintained as part of raven-js.  Tests for\n this are in test/vendor.\n\n MIT license\n*/\n\nvar TraceKit = {\n  collectWindowErrors: true,\n  debug: false\n};\n\n// This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)\nvar _window = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n// global reference to slice\nvar _slice = [].slice;\nvar UNKNOWN_FUNCTION = '?';\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types\nvar ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/;\nfunction getLocationHref() {\n  if (typeof document === 'undefined' || document.location == null) return '';\n  return document.location.href;\n}\nfunction getLocationOrigin() {\n  if (typeof document === 'undefined' || document.location == null) return '';\n\n  // Oh dear IE10...\n  if (!document.location.origin) {\n    return document.location.protocol + '//' + document.location.hostname + (document.location.port ? ':' + document.location.port : '');\n  }\n  return document.location.origin;\n}\n\n/**\n * TraceKit.report: cross-browser processing of unhandled exceptions\n *\n * Syntax:\n *   TraceKit.report.subscribe(function(stackInfo) { ... })\n *   TraceKit.report.unsubscribe(function(stackInfo) { ... })\n *   TraceKit.report(exception)\n *   try { ...code... } catch(ex) { TraceKit.report(ex); }\n *\n * Supports:\n *   - Firefox: full stack trace with line numbers, plus column number\n *              on top frame; column number is not guaranteed\n *   - Opera:   full stack trace with line and column numbers\n *   - Chrome:  full stack trace with line and column numbers\n *   - Safari:  line and column number for the top frame only; some frames\n *              may be missing, and column number is not guaranteed\n *   - IE:      line and column number for the top frame only; some frames\n *              may be missing, and column number is not guaranteed\n *\n * In theory, TraceKit should work on all of the following versions:\n *   - IE5.5+ (only 8.0 tested)\n *   - Firefox 0.9+ (only 3.5+ tested)\n *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require\n *     Exceptions Have Stacktrace to be enabled in opera:config)\n *   - Safari 3+ (only 4+ tested)\n *   - Chrome 1+ (only 5+ tested)\n *   - Konqueror 3.5+ (untested)\n *\n * Requires TraceKit.computeStackTrace.\n *\n * Tries to catch all unhandled exceptions and report them to the\n * subscribed handlers. Please note that TraceKit.report will rethrow the\n * exception. This is REQUIRED in order to get a useful stack trace in IE.\n * If the exception does not reach the top of the browser, you will only\n * get a stack trace from the point where TraceKit.report was called.\n *\n * Handlers receive a stackInfo object as described in the\n * TraceKit.computeStackTrace docs.\n */\nTraceKit.report = function reportModuleWrapper() {\n  var handlers = [],\n    lastArgs = null,\n    lastException = null,\n    lastExceptionStack = null;\n\n  /**\n   * Add a crash handler.\n   * @param {Function} handler\n   */\n  function subscribe(handler) {\n    installGlobalHandler();\n    handlers.push(handler);\n  }\n\n  /**\n   * Remove a crash handler.\n   * @param {Function} handler\n   */\n  function unsubscribe(handler) {\n    for (var i = handlers.length - 1; i >= 0; --i) {\n      if (handlers[i] === handler) {\n        handlers.splice(i, 1);\n      }\n    }\n  }\n\n  /**\n   * Remove all crash handlers.\n   */\n  function unsubscribeAll() {\n    uninstallGlobalHandler();\n    handlers = [];\n  }\n\n  /**\n   * Dispatch stack information to all handlers.\n   * @param {Object.<string, *>} stack\n   */\n  function notifyHandlers(stack, isWindowError) {\n    var exception = null;\n    if (isWindowError && !TraceKit.collectWindowErrors) {\n      return;\n    }\n    for (var i in handlers) {\n      if (handlers.hasOwnProperty(i)) {\n        try {\n          handlers[i].apply(null, [stack].concat(_slice.call(arguments, 2)));\n        } catch (inner) {\n          exception = inner;\n        }\n      }\n    }\n    if (exception) {\n      throw exception;\n    }\n  }\n  var _oldOnerrorHandler, _onErrorHandlerInstalled;\n\n  /**\n   * Ensures all global unhandled exceptions are recorded.\n   * Supported by Gecko and IE.\n   * @param {string} msg Error message.\n   * @param {string} url URL of script that generated the exception.\n   * @param {(number|string)} lineNo The line number at which the error\n   * occurred.\n   * @param {?(number|string)} colNo The column number at which the error\n   * occurred.\n   * @param {?Error} ex The actual Error object.\n   */\n  function traceKitWindowOnError(msg, url, lineNo, colNo, ex) {\n    var stack = null;\n    // If 'ex' is ErrorEvent, get real Error from inside\n    var exception = utils.isErrorEvent(ex) ? ex.error : ex;\n    // If 'msg' is ErrorEvent, get real message from inside\n    var message = utils.isErrorEvent(msg) ? msg.message : msg;\n    if (lastExceptionStack) {\n      TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(lastExceptionStack, url, lineNo, message);\n      processLastException();\n    } else if (exception && utils.isError(exception)) {\n      // non-string `exception` arg; attempt to extract stack trace\n\n      // New chrome and blink send along a real error object\n      // Let's just report that like a normal error.\n      // See: https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror\n      stack = TraceKit.computeStackTrace(exception);\n      notifyHandlers(stack, true);\n    } else {\n      var location = {\n        url: url,\n        line: lineNo,\n        column: colNo\n      };\n      var name = undefined;\n      var groups;\n      if ({}.toString.call(message) === '[object String]') {\n        var groups = message.match(ERROR_TYPES_RE);\n        if (groups) {\n          name = groups[1];\n          message = groups[2];\n        }\n      }\n      location.func = UNKNOWN_FUNCTION;\n      stack = {\n        name: name,\n        message: message,\n        url: getLocationHref(),\n        stack: [location]\n      };\n      notifyHandlers(stack, true);\n    }\n    if (_oldOnerrorHandler) {\n      return _oldOnerrorHandler.apply(this, arguments);\n    }\n    return false;\n  }\n  function installGlobalHandler() {\n    if (_onErrorHandlerInstalled) {\n      return;\n    }\n    _oldOnerrorHandler = _window.onerror;\n    _window.onerror = traceKitWindowOnError;\n    _onErrorHandlerInstalled = true;\n  }\n  function uninstallGlobalHandler() {\n    if (!_onErrorHandlerInstalled) {\n      return;\n    }\n    _window.onerror = _oldOnerrorHandler;\n    _onErrorHandlerInstalled = false;\n    _oldOnerrorHandler = undefined;\n  }\n  function processLastException() {\n    var _lastExceptionStack = lastExceptionStack,\n      _lastArgs = lastArgs;\n    lastArgs = null;\n    lastExceptionStack = null;\n    lastException = null;\n    notifyHandlers.apply(null, [_lastExceptionStack, false].concat(_lastArgs));\n  }\n\n  /**\n   * Reports an unhandled Error to TraceKit.\n   * @param {Error} ex\n   * @param {?boolean} rethrow If false, do not re-throw the exception.\n   * Only used for window.onerror to not cause an infinite loop of\n   * rethrowing.\n   */\n  function report(ex, rethrow) {\n    var args = _slice.call(arguments, 1);\n    if (lastExceptionStack) {\n      if (lastException === ex) {\n        return; // already caught by an inner catch block, ignore\n      } else {\n        processLastException();\n      }\n    }\n    var stack = TraceKit.computeStackTrace(ex);\n    lastExceptionStack = stack;\n    lastException = ex;\n    lastArgs = args;\n\n    // If the stack trace is incomplete, wait for 2 seconds for\n    // slow slow IE to see if onerror occurs or not before reporting\n    // this exception; otherwise, we will end up with an incomplete\n    // stack trace\n    setTimeout(function () {\n      if (lastException === ex) {\n        processLastException();\n      }\n    }, stack.incomplete ? 2000 : 0);\n    if (rethrow !== false) {\n      throw ex; // re-throw to propagate to the top level (and cause window.onerror)\n    }\n  }\n  report.subscribe = subscribe;\n  report.unsubscribe = unsubscribe;\n  report.uninstall = unsubscribeAll;\n  return report;\n}();\n\n/**\n * TraceKit.computeStackTrace: cross-browser stack traces in JavaScript\n *\n * Syntax:\n *   s = TraceKit.computeStackTrace(exception) // consider using TraceKit.report instead (see below)\n * Returns:\n *   s.name              - exception name\n *   s.message           - exception message\n *   s.stack[i].url      - JavaScript or HTML file URL\n *   s.stack[i].func     - function name, or empty for anonymous functions (if guessing did not work)\n *   s.stack[i].args     - arguments passed to the function, if known\n *   s.stack[i].line     - line number, if known\n *   s.stack[i].column   - column number, if known\n *\n * Supports:\n *   - Firefox:  full stack trace with line numbers and unreliable column\n *               number on top frame\n *   - Opera 10: full stack trace with line and column numbers\n *   - Opera 9-: full stack trace with line numbers\n *   - Chrome:   full stack trace with line and column numbers\n *   - Safari:   line and column number for the topmost stacktrace element\n *               only\n *   - IE:       no line numbers whatsoever\n *\n * Tries to guess names of anonymous functions by looking for assignments\n * in the source code. In IE and Safari, we have to guess source file names\n * by searching for function bodies inside all page scripts. This will not\n * work for scripts that are loaded cross-domain.\n * Here be dragons: some function names may be guessed incorrectly, and\n * duplicate functions may be mismatched.\n *\n * TraceKit.computeStackTrace should only be used for tracing purposes.\n * Logging of unhandled exceptions should be done with TraceKit.report,\n * which builds on top of TraceKit.computeStackTrace and provides better\n * IE support by utilizing the window.onerror event to retrieve information\n * about the top of the stack.\n *\n * Note: In IE and Safari, no stack trace is recorded on the Error object,\n * so computeStackTrace instead walks its *own* chain of callers.\n * This means that:\n *  * in Safari, some methods may be missing from the stack trace;\n *  * in IE, the topmost function in the stack trace will always be the\n *    caller of computeStackTrace.\n *\n * This is okay for tracing (because you are likely to be calling\n * computeStackTrace from the function you want to be the topmost element\n * of the stack trace anyway), but not okay for logging unhandled\n * exceptions (because your catch block will likely be far away from the\n * inner function that actually caused the exception).\n *\n */\nTraceKit.computeStackTrace = function computeStackTraceWrapper() {\n  // Contents of Exception in various browsers.\n  //\n  // SAFARI:\n  // ex.message = Can't find variable: qq\n  // ex.line = 59\n  // ex.sourceId = 580238192\n  // ex.sourceURL = http://...\n  // ex.expressionBeginOffset = 96\n  // ex.expressionCaretOffset = 98\n  // ex.expressionEndOffset = 98\n  // ex.name = ReferenceError\n  //\n  // FIREFOX:\n  // ex.message = qq is not defined\n  // ex.fileName = http://...\n  // ex.lineNumber = 59\n  // ex.columnNumber = 69\n  // ex.stack = ...stack trace... (see the example below)\n  // ex.name = ReferenceError\n  //\n  // CHROME:\n  // ex.message = qq is not defined\n  // ex.name = ReferenceError\n  // ex.type = not_defined\n  // ex.arguments = ['aa']\n  // ex.stack = ...stack trace...\n  //\n  // INTERNET EXPLORER:\n  // ex.message = ...\n  // ex.name = ReferenceError\n  //\n  // OPERA:\n  // ex.message = ...message... (see the example below)\n  // ex.name = ReferenceError\n  // ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)\n  // ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'\n\n  /**\n   * Computes stack trace information from the stack property.\n   * Chrome and Gecko use this property.\n   * @param {Error} ex\n   * @return {?Object.<string, *>} Stack trace information.\n   */\n  function computeStackTraceFromStackProp(ex) {\n    if (typeof ex.stack === 'undefined' || !ex.stack) return;\n    var chrome = /^\\s*at (?:(.*?) ?\\()?((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|[a-z]:|\\/).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\n    var winjs = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx(?:-web)|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n    // NOTE: blob urls are now supposed to always have an origin, therefore it's format\n    // which is `blob:http://url/path/with-some-uuid`, is matched by `blob.*?:\\/` as well\n    var gecko = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|moz-extension).*?:\\/.*?|\\[native code\\]|[^@]*(?:bundle|\\d+\\.js))(?::(\\d+))?(?::(\\d+))?\\s*$/i;\n    // Used to additionally parse URL/line/column from eval frames\n    var geckoEval = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\n    var chromeEval = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\n    var lines = ex.stack.split('\\n');\n    var stack = [];\n    var submatch;\n    var parts;\n    var element;\n    var reference = /^(.*) is undefined$/.exec(ex.message);\n    for (var i = 0, j = lines.length; i < j; ++i) {\n      if (parts = chrome.exec(lines[i])) {\n        var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line\n        var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n        if (isEval && (submatch = chromeEval.exec(parts[2]))) {\n          // throw out eval line/column and use top-most line/column number\n          parts[2] = submatch[1]; // url\n          parts[3] = submatch[2]; // line\n          parts[4] = submatch[3]; // column\n        }\n        element = {\n          url: !isNative ? parts[2] : null,\n          func: parts[1] || UNKNOWN_FUNCTION,\n          args: isNative ? [parts[2]] : [],\n          line: parts[3] ? +parts[3] : null,\n          column: parts[4] ? +parts[4] : null\n        };\n      } else if (parts = winjs.exec(lines[i])) {\n        element = {\n          url: parts[2],\n          func: parts[1] || UNKNOWN_FUNCTION,\n          args: [],\n          line: +parts[3],\n          column: parts[4] ? +parts[4] : null\n        };\n      } else if (parts = gecko.exec(lines[i])) {\n        var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n        if (isEval && (submatch = geckoEval.exec(parts[3]))) {\n          // throw out eval line/column and use top-most line number\n          parts[3] = submatch[1];\n          parts[4] = submatch[2];\n          parts[5] = null; // no column when eval\n        } else if (i === 0 && !parts[5] && typeof ex.columnNumber !== 'undefined') {\n          // FireFox uses this awesome columnNumber property for its top frame\n          // Also note, Firefox's column number is 0-based and everything else expects 1-based,\n          // so adding 1\n          // NOTE: this hack doesn't work if top-most frame is eval\n          stack[0].column = ex.columnNumber + 1;\n        }\n        element = {\n          url: parts[3],\n          func: parts[1] || UNKNOWN_FUNCTION,\n          args: parts[2] ? parts[2].split(',') : [],\n          line: parts[4] ? +parts[4] : null,\n          column: parts[5] ? +parts[5] : null\n        };\n      } else {\n        continue;\n      }\n      if (!element.func && element.line) {\n        element.func = UNKNOWN_FUNCTION;\n      }\n      if (element.url && element.url.substr(0, 5) === 'blob:') {\n        // Special case for handling JavaScript loaded into a blob.\n        // We use a synchronous AJAX request here as a blob is already in\n        // memory - it's not making a network request.  This will generate a warning\n        // in the browser console, but there has already been an error so that's not\n        // that much of an issue.\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', element.url, false);\n        xhr.send(null);\n\n        // If we failed to download the source, skip this patch\n        if (xhr.status === 200) {\n          var source = xhr.responseText || '';\n\n          // We trim the source down to the last 300 characters as sourceMappingURL is always at the end of the file.\n          // Why 300? To be in line with: https://github.com/getsentry/sentry/blob/4af29e8f2350e20c28a6933354e4f42437b4ba42/src/sentry/lang/javascript/processor.py#L164-L175\n          source = source.slice(-300);\n\n          // Now we dig out the source map URL\n          var sourceMaps = source.match(/\\/\\/# sourceMappingURL=(.*)$/);\n\n          // If we don't find a source map comment or we find more than one, continue on to the next element.\n          if (sourceMaps) {\n            var sourceMapAddress = sourceMaps[1];\n\n            // Now we check to see if it's a relative URL.\n            // If it is, convert it to an absolute one.\n            if (sourceMapAddress.charAt(0) === '~') {\n              sourceMapAddress = getLocationOrigin() + sourceMapAddress.slice(1);\n            }\n\n            // Now we strip the '.map' off of the end of the URL and update the\n            // element so that Sentry can match the map to the blob.\n            element.url = sourceMapAddress.slice(0, -4);\n          }\n        }\n      }\n      stack.push(element);\n    }\n    if (!stack.length) {\n      return null;\n    }\n    return {\n      name: ex.name,\n      message: ex.message,\n      url: getLocationHref(),\n      stack: stack\n    };\n  }\n\n  /**\n   * Adds information about the first frame to incomplete stack traces.\n   * Safari and IE require this to get complete data on the first frame.\n   * @param {Object.<string, *>} stackInfo Stack trace information from\n   * one of the compute* methods.\n   * @param {string} url The URL of the script that caused an error.\n   * @param {(number|string)} lineNo The line number of the script that\n   * caused an error.\n   * @param {string=} message The error generated by the browser, which\n   * hopefully contains the name of the object that caused the error.\n   * @return {boolean} Whether or not the stack information was\n   * augmented.\n   */\n  function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {\n    var initial = {\n      url: url,\n      line: lineNo\n    };\n    if (initial.url && initial.line) {\n      stackInfo.incomplete = false;\n      if (!initial.func) {\n        initial.func = UNKNOWN_FUNCTION;\n      }\n      if (stackInfo.stack.length > 0) {\n        if (stackInfo.stack[0].url === initial.url) {\n          if (stackInfo.stack[0].line === initial.line) {\n            return false; // already in stack trace\n          } else if (!stackInfo.stack[0].line && stackInfo.stack[0].func === initial.func) {\n            stackInfo.stack[0].line = initial.line;\n            return false;\n          }\n        }\n      }\n      stackInfo.stack.unshift(initial);\n      stackInfo.partial = true;\n      return true;\n    } else {\n      stackInfo.incomplete = true;\n    }\n    return false;\n  }\n\n  /**\n   * Computes stack trace information by walking the arguments.caller\n   * chain at the time the exception occurred. This will cause earlier\n   * frames to be missed but is the only way to get any stack trace in\n   * Safari and IE. The top frame is restored by\n   * {@link augmentStackTraceWithInitialElement}.\n   * @param {Error} ex\n   * @return {?Object.<string, *>} Stack trace information.\n   */\n  function computeStackTraceByWalkingCallerChain(ex, depth) {\n    var functionName = /function\\s+([_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*)?\\s*\\(/i,\n      stack = [],\n      funcs = {},\n      recursion = false,\n      parts,\n      item,\n      source;\n    for (var curr = computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {\n      if (curr === computeStackTrace || curr === TraceKit.report) {\n        // console.log('skipping internal function');\n        continue;\n      }\n      item = {\n        url: null,\n        func: UNKNOWN_FUNCTION,\n        line: null,\n        column: null\n      };\n      if (curr.name) {\n        item.func = curr.name;\n      } else if (parts = functionName.exec(curr.toString())) {\n        item.func = parts[1];\n      }\n      if (typeof item.func === 'undefined') {\n        try {\n          item.func = parts.input.substring(0, parts.input.indexOf('{'));\n        } catch (e) {}\n      }\n      if (funcs['' + curr]) {\n        recursion = true;\n      } else {\n        funcs['' + curr] = true;\n      }\n      stack.push(item);\n    }\n    if (depth) {\n      // console.log('depth is ' + depth);\n      // console.log('stack is ' + stack.length);\n      stack.splice(0, depth);\n    }\n    var result = {\n      name: ex.name,\n      message: ex.message,\n      url: getLocationHref(),\n      stack: stack\n    };\n    augmentStackTraceWithInitialElement(result, ex.sourceURL || ex.fileName, ex.line || ex.lineNumber, ex.message || ex.description);\n    return result;\n  }\n\n  /**\n   * Computes a stack trace for an exception.\n   * @param {Error} ex\n   * @param {(string|number)=} depth\n   */\n  function computeStackTrace(ex, depth) {\n    var stack = null;\n    depth = depth == null ? 0 : +depth;\n    try {\n      stack = computeStackTraceFromStackProp(ex);\n      if (stack) {\n        return stack;\n      }\n    } catch (e) {\n      if (TraceKit.debug) {\n        throw e;\n      }\n    }\n    try {\n      stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);\n      if (stack) {\n        return stack;\n      }\n    } catch (e) {\n      if (TraceKit.debug) {\n        throw e;\n      }\n    }\n    return {\n      name: ex.name,\n      message: ex.message,\n      url: getLocationHref()\n    };\n  }\n  computeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;\n  computeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;\n  return computeStackTrace;\n}();\nmodule.exports = TraceKit;","map":{"version":3,"names":["utils","require","TraceKit","collectWindowErrors","debug","_window","window","global","self","_slice","slice","UNKNOWN_FUNCTION","ERROR_TYPES_RE","getLocationHref","document","location","href","getLocationOrigin","origin","protocol","hostname","port","report","reportModuleWrapper","handlers","lastArgs","lastException","lastExceptionStack","subscribe","handler","installGlobalHandler","push","unsubscribe","i","length","splice","unsubscribeAll","uninstallGlobalHandler","notifyHandlers","stack","isWindowError","exception","hasOwnProperty","apply","concat","call","arguments","inner","_oldOnerrorHandler","_onErrorHandlerInstalled","traceKitWindowOnError","msg","url","lineNo","colNo","ex","isErrorEvent","error","message","computeStackTrace","augmentStackTraceWithInitialElement","processLastException","isError","line","column","name","undefined","groups","toString","match","func","onerror","_lastExceptionStack","_lastArgs","rethrow","args","setTimeout","incomplete","uninstall","computeStackTraceWrapper","computeStackTraceFromStackProp","chrome","winjs","gecko","geckoEval","chromeEval","lines","split","submatch","parts","element","reference","exec","j","isNative","indexOf","isEval","columnNumber","substr","xhr","XMLHttpRequest","open","send","status","source","responseText","sourceMaps","sourceMapAddress","charAt","stackInfo","initial","unshift","partial","computeStackTraceByWalkingCallerChain","depth","functionName","funcs","recursion","item","curr","caller","input","substring","e","result","sourceURL","fileName","lineNumber","description","module","exports"],"sources":["/Users/viacheslv/devlop/aivazynPay/client/node_modules/raven-js/vendor/TraceKit/tracekit.js"],"sourcesContent":["var utils = require('../../src/utils');\n\n/*\n TraceKit - Cross brower stack traces\n\n This was originally forked from github.com/occ/TraceKit, but has since been\n largely re-written and is now maintained as part of raven-js.  Tests for\n this are in test/vendor.\n\n MIT license\n*/\n\nvar TraceKit = {\n  collectWindowErrors: true,\n  debug: false\n};\n\n// This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)\nvar _window =\n  typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined'\n    ? global\n    : typeof self !== 'undefined'\n    ? self\n    : {};\n\n// global reference to slice\nvar _slice = [].slice;\nvar UNKNOWN_FUNCTION = '?';\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types\nvar ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/;\n\nfunction getLocationHref() {\n  if (typeof document === 'undefined' || document.location == null) return '';\n  return document.location.href;\n}\n\nfunction getLocationOrigin() {\n  if (typeof document === 'undefined' || document.location == null) return '';\n\n  // Oh dear IE10...\n  if (!document.location.origin) {\n    return (\n      document.location.protocol +\n      '//' +\n      document.location.hostname +\n      (document.location.port ? ':' + document.location.port : '')\n    );\n  }\n\n  return document.location.origin;\n}\n\n/**\n * TraceKit.report: cross-browser processing of unhandled exceptions\n *\n * Syntax:\n *   TraceKit.report.subscribe(function(stackInfo) { ... })\n *   TraceKit.report.unsubscribe(function(stackInfo) { ... })\n *   TraceKit.report(exception)\n *   try { ...code... } catch(ex) { TraceKit.report(ex); }\n *\n * Supports:\n *   - Firefox: full stack trace with line numbers, plus column number\n *              on top frame; column number is not guaranteed\n *   - Opera:   full stack trace with line and column numbers\n *   - Chrome:  full stack trace with line and column numbers\n *   - Safari:  line and column number for the top frame only; some frames\n *              may be missing, and column number is not guaranteed\n *   - IE:      line and column number for the top frame only; some frames\n *              may be missing, and column number is not guaranteed\n *\n * In theory, TraceKit should work on all of the following versions:\n *   - IE5.5+ (only 8.0 tested)\n *   - Firefox 0.9+ (only 3.5+ tested)\n *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require\n *     Exceptions Have Stacktrace to be enabled in opera:config)\n *   - Safari 3+ (only 4+ tested)\n *   - Chrome 1+ (only 5+ tested)\n *   - Konqueror 3.5+ (untested)\n *\n * Requires TraceKit.computeStackTrace.\n *\n * Tries to catch all unhandled exceptions and report them to the\n * subscribed handlers. Please note that TraceKit.report will rethrow the\n * exception. This is REQUIRED in order to get a useful stack trace in IE.\n * If the exception does not reach the top of the browser, you will only\n * get a stack trace from the point where TraceKit.report was called.\n *\n * Handlers receive a stackInfo object as described in the\n * TraceKit.computeStackTrace docs.\n */\nTraceKit.report = (function reportModuleWrapper() {\n  var handlers = [],\n    lastArgs = null,\n    lastException = null,\n    lastExceptionStack = null;\n\n  /**\n   * Add a crash handler.\n   * @param {Function} handler\n   */\n  function subscribe(handler) {\n    installGlobalHandler();\n    handlers.push(handler);\n  }\n\n  /**\n   * Remove a crash handler.\n   * @param {Function} handler\n   */\n  function unsubscribe(handler) {\n    for (var i = handlers.length - 1; i >= 0; --i) {\n      if (handlers[i] === handler) {\n        handlers.splice(i, 1);\n      }\n    }\n  }\n\n  /**\n   * Remove all crash handlers.\n   */\n  function unsubscribeAll() {\n    uninstallGlobalHandler();\n    handlers = [];\n  }\n\n  /**\n   * Dispatch stack information to all handlers.\n   * @param {Object.<string, *>} stack\n   */\n  function notifyHandlers(stack, isWindowError) {\n    var exception = null;\n    if (isWindowError && !TraceKit.collectWindowErrors) {\n      return;\n    }\n    for (var i in handlers) {\n      if (handlers.hasOwnProperty(i)) {\n        try {\n          handlers[i].apply(null, [stack].concat(_slice.call(arguments, 2)));\n        } catch (inner) {\n          exception = inner;\n        }\n      }\n    }\n\n    if (exception) {\n      throw exception;\n    }\n  }\n\n  var _oldOnerrorHandler, _onErrorHandlerInstalled;\n\n  /**\n   * Ensures all global unhandled exceptions are recorded.\n   * Supported by Gecko and IE.\n   * @param {string} msg Error message.\n   * @param {string} url URL of script that generated the exception.\n   * @param {(number|string)} lineNo The line number at which the error\n   * occurred.\n   * @param {?(number|string)} colNo The column number at which the error\n   * occurred.\n   * @param {?Error} ex The actual Error object.\n   */\n  function traceKitWindowOnError(msg, url, lineNo, colNo, ex) {\n    var stack = null;\n    // If 'ex' is ErrorEvent, get real Error from inside\n    var exception = utils.isErrorEvent(ex) ? ex.error : ex;\n    // If 'msg' is ErrorEvent, get real message from inside\n    var message = utils.isErrorEvent(msg) ? msg.message : msg;\n\n    if (lastExceptionStack) {\n      TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(\n        lastExceptionStack,\n        url,\n        lineNo,\n        message\n      );\n      processLastException();\n    } else if (exception && utils.isError(exception)) {\n      // non-string `exception` arg; attempt to extract stack trace\n\n      // New chrome and blink send along a real error object\n      // Let's just report that like a normal error.\n      // See: https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror\n      stack = TraceKit.computeStackTrace(exception);\n      notifyHandlers(stack, true);\n    } else {\n      var location = {\n        url: url,\n        line: lineNo,\n        column: colNo\n      };\n\n      var name = undefined;\n      var groups;\n\n      if ({}.toString.call(message) === '[object String]') {\n        var groups = message.match(ERROR_TYPES_RE);\n        if (groups) {\n          name = groups[1];\n          message = groups[2];\n        }\n      }\n\n      location.func = UNKNOWN_FUNCTION;\n\n      stack = {\n        name: name,\n        message: message,\n        url: getLocationHref(),\n        stack: [location]\n      };\n      notifyHandlers(stack, true);\n    }\n\n    if (_oldOnerrorHandler) {\n      return _oldOnerrorHandler.apply(this, arguments);\n    }\n\n    return false;\n  }\n\n  function installGlobalHandler() {\n    if (_onErrorHandlerInstalled) {\n      return;\n    }\n    _oldOnerrorHandler = _window.onerror;\n    _window.onerror = traceKitWindowOnError;\n    _onErrorHandlerInstalled = true;\n  }\n\n  function uninstallGlobalHandler() {\n    if (!_onErrorHandlerInstalled) {\n      return;\n    }\n    _window.onerror = _oldOnerrorHandler;\n    _onErrorHandlerInstalled = false;\n    _oldOnerrorHandler = undefined;\n  }\n\n  function processLastException() {\n    var _lastExceptionStack = lastExceptionStack,\n      _lastArgs = lastArgs;\n    lastArgs = null;\n    lastExceptionStack = null;\n    lastException = null;\n    notifyHandlers.apply(null, [_lastExceptionStack, false].concat(_lastArgs));\n  }\n\n  /**\n   * Reports an unhandled Error to TraceKit.\n   * @param {Error} ex\n   * @param {?boolean} rethrow If false, do not re-throw the exception.\n   * Only used for window.onerror to not cause an infinite loop of\n   * rethrowing.\n   */\n  function report(ex, rethrow) {\n    var args = _slice.call(arguments, 1);\n    if (lastExceptionStack) {\n      if (lastException === ex) {\n        return; // already caught by an inner catch block, ignore\n      } else {\n        processLastException();\n      }\n    }\n\n    var stack = TraceKit.computeStackTrace(ex);\n    lastExceptionStack = stack;\n    lastException = ex;\n    lastArgs = args;\n\n    // If the stack trace is incomplete, wait for 2 seconds for\n    // slow slow IE to see if onerror occurs or not before reporting\n    // this exception; otherwise, we will end up with an incomplete\n    // stack trace\n    setTimeout(\n      function() {\n        if (lastException === ex) {\n          processLastException();\n        }\n      },\n      stack.incomplete ? 2000 : 0\n    );\n\n    if (rethrow !== false) {\n      throw ex; // re-throw to propagate to the top level (and cause window.onerror)\n    }\n  }\n\n  report.subscribe = subscribe;\n  report.unsubscribe = unsubscribe;\n  report.uninstall = unsubscribeAll;\n  return report;\n})();\n\n/**\n * TraceKit.computeStackTrace: cross-browser stack traces in JavaScript\n *\n * Syntax:\n *   s = TraceKit.computeStackTrace(exception) // consider using TraceKit.report instead (see below)\n * Returns:\n *   s.name              - exception name\n *   s.message           - exception message\n *   s.stack[i].url      - JavaScript or HTML file URL\n *   s.stack[i].func     - function name, or empty for anonymous functions (if guessing did not work)\n *   s.stack[i].args     - arguments passed to the function, if known\n *   s.stack[i].line     - line number, if known\n *   s.stack[i].column   - column number, if known\n *\n * Supports:\n *   - Firefox:  full stack trace with line numbers and unreliable column\n *               number on top frame\n *   - Opera 10: full stack trace with line and column numbers\n *   - Opera 9-: full stack trace with line numbers\n *   - Chrome:   full stack trace with line and column numbers\n *   - Safari:   line and column number for the topmost stacktrace element\n *               only\n *   - IE:       no line numbers whatsoever\n *\n * Tries to guess names of anonymous functions by looking for assignments\n * in the source code. In IE and Safari, we have to guess source file names\n * by searching for function bodies inside all page scripts. This will not\n * work for scripts that are loaded cross-domain.\n * Here be dragons: some function names may be guessed incorrectly, and\n * duplicate functions may be mismatched.\n *\n * TraceKit.computeStackTrace should only be used for tracing purposes.\n * Logging of unhandled exceptions should be done with TraceKit.report,\n * which builds on top of TraceKit.computeStackTrace and provides better\n * IE support by utilizing the window.onerror event to retrieve information\n * about the top of the stack.\n *\n * Note: In IE and Safari, no stack trace is recorded on the Error object,\n * so computeStackTrace instead walks its *own* chain of callers.\n * This means that:\n *  * in Safari, some methods may be missing from the stack trace;\n *  * in IE, the topmost function in the stack trace will always be the\n *    caller of computeStackTrace.\n *\n * This is okay for tracing (because you are likely to be calling\n * computeStackTrace from the function you want to be the topmost element\n * of the stack trace anyway), but not okay for logging unhandled\n * exceptions (because your catch block will likely be far away from the\n * inner function that actually caused the exception).\n *\n */\nTraceKit.computeStackTrace = (function computeStackTraceWrapper() {\n  // Contents of Exception in various browsers.\n  //\n  // SAFARI:\n  // ex.message = Can't find variable: qq\n  // ex.line = 59\n  // ex.sourceId = 580238192\n  // ex.sourceURL = http://...\n  // ex.expressionBeginOffset = 96\n  // ex.expressionCaretOffset = 98\n  // ex.expressionEndOffset = 98\n  // ex.name = ReferenceError\n  //\n  // FIREFOX:\n  // ex.message = qq is not defined\n  // ex.fileName = http://...\n  // ex.lineNumber = 59\n  // ex.columnNumber = 69\n  // ex.stack = ...stack trace... (see the example below)\n  // ex.name = ReferenceError\n  //\n  // CHROME:\n  // ex.message = qq is not defined\n  // ex.name = ReferenceError\n  // ex.type = not_defined\n  // ex.arguments = ['aa']\n  // ex.stack = ...stack trace...\n  //\n  // INTERNET EXPLORER:\n  // ex.message = ...\n  // ex.name = ReferenceError\n  //\n  // OPERA:\n  // ex.message = ...message... (see the example below)\n  // ex.name = ReferenceError\n  // ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)\n  // ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'\n\n  /**\n   * Computes stack trace information from the stack property.\n   * Chrome and Gecko use this property.\n   * @param {Error} ex\n   * @return {?Object.<string, *>} Stack trace information.\n   */\n  function computeStackTraceFromStackProp(ex) {\n    if (typeof ex.stack === 'undefined' || !ex.stack) return;\n\n    var chrome = /^\\s*at (?:(.*?) ?\\()?((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|[a-z]:|\\/).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\n    var winjs = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx(?:-web)|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n    // NOTE: blob urls are now supposed to always have an origin, therefore it's format\n    // which is `blob:http://url/path/with-some-uuid`, is matched by `blob.*?:\\/` as well\n    var gecko = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|moz-extension).*?:\\/.*?|\\[native code\\]|[^@]*(?:bundle|\\d+\\.js))(?::(\\d+))?(?::(\\d+))?\\s*$/i;\n    // Used to additionally parse URL/line/column from eval frames\n    var geckoEval = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\n    var chromeEval = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\n    var lines = ex.stack.split('\\n');\n    var stack = [];\n    var submatch;\n    var parts;\n    var element;\n    var reference = /^(.*) is undefined$/.exec(ex.message);\n\n    for (var i = 0, j = lines.length; i < j; ++i) {\n      if ((parts = chrome.exec(lines[i]))) {\n        var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line\n        var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n        if (isEval && (submatch = chromeEval.exec(parts[2]))) {\n          // throw out eval line/column and use top-most line/column number\n          parts[2] = submatch[1]; // url\n          parts[3] = submatch[2]; // line\n          parts[4] = submatch[3]; // column\n        }\n        element = {\n          url: !isNative ? parts[2] : null,\n          func: parts[1] || UNKNOWN_FUNCTION,\n          args: isNative ? [parts[2]] : [],\n          line: parts[3] ? +parts[3] : null,\n          column: parts[4] ? +parts[4] : null\n        };\n      } else if ((parts = winjs.exec(lines[i]))) {\n        element = {\n          url: parts[2],\n          func: parts[1] || UNKNOWN_FUNCTION,\n          args: [],\n          line: +parts[3],\n          column: parts[4] ? +parts[4] : null\n        };\n      } else if ((parts = gecko.exec(lines[i]))) {\n        var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n        if (isEval && (submatch = geckoEval.exec(parts[3]))) {\n          // throw out eval line/column and use top-most line number\n          parts[3] = submatch[1];\n          parts[4] = submatch[2];\n          parts[5] = null; // no column when eval\n        } else if (i === 0 && !parts[5] && typeof ex.columnNumber !== 'undefined') {\n          // FireFox uses this awesome columnNumber property for its top frame\n          // Also note, Firefox's column number is 0-based and everything else expects 1-based,\n          // so adding 1\n          // NOTE: this hack doesn't work if top-most frame is eval\n          stack[0].column = ex.columnNumber + 1;\n        }\n        element = {\n          url: parts[3],\n          func: parts[1] || UNKNOWN_FUNCTION,\n          args: parts[2] ? parts[2].split(',') : [],\n          line: parts[4] ? +parts[4] : null,\n          column: parts[5] ? +parts[5] : null\n        };\n      } else {\n        continue;\n      }\n\n      if (!element.func && element.line) {\n        element.func = UNKNOWN_FUNCTION;\n      }\n\n      if (element.url && element.url.substr(0, 5) === 'blob:') {\n        // Special case for handling JavaScript loaded into a blob.\n        // We use a synchronous AJAX request here as a blob is already in\n        // memory - it's not making a network request.  This will generate a warning\n        // in the browser console, but there has already been an error so that's not\n        // that much of an issue.\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', element.url, false);\n        xhr.send(null);\n\n        // If we failed to download the source, skip this patch\n        if (xhr.status === 200) {\n          var source = xhr.responseText || '';\n\n          // We trim the source down to the last 300 characters as sourceMappingURL is always at the end of the file.\n          // Why 300? To be in line with: https://github.com/getsentry/sentry/blob/4af29e8f2350e20c28a6933354e4f42437b4ba42/src/sentry/lang/javascript/processor.py#L164-L175\n          source = source.slice(-300);\n\n          // Now we dig out the source map URL\n          var sourceMaps = source.match(/\\/\\/# sourceMappingURL=(.*)$/);\n\n          // If we don't find a source map comment or we find more than one, continue on to the next element.\n          if (sourceMaps) {\n            var sourceMapAddress = sourceMaps[1];\n\n            // Now we check to see if it's a relative URL.\n            // If it is, convert it to an absolute one.\n            if (sourceMapAddress.charAt(0) === '~') {\n              sourceMapAddress = getLocationOrigin() + sourceMapAddress.slice(1);\n            }\n\n            // Now we strip the '.map' off of the end of the URL and update the\n            // element so that Sentry can match the map to the blob.\n            element.url = sourceMapAddress.slice(0, -4);\n          }\n        }\n      }\n\n      stack.push(element);\n    }\n\n    if (!stack.length) {\n      return null;\n    }\n\n    return {\n      name: ex.name,\n      message: ex.message,\n      url: getLocationHref(),\n      stack: stack\n    };\n  }\n\n  /**\n   * Adds information about the first frame to incomplete stack traces.\n   * Safari and IE require this to get complete data on the first frame.\n   * @param {Object.<string, *>} stackInfo Stack trace information from\n   * one of the compute* methods.\n   * @param {string} url The URL of the script that caused an error.\n   * @param {(number|string)} lineNo The line number of the script that\n   * caused an error.\n   * @param {string=} message The error generated by the browser, which\n   * hopefully contains the name of the object that caused the error.\n   * @return {boolean} Whether or not the stack information was\n   * augmented.\n   */\n  function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {\n    var initial = {\n      url: url,\n      line: lineNo\n    };\n\n    if (initial.url && initial.line) {\n      stackInfo.incomplete = false;\n\n      if (!initial.func) {\n        initial.func = UNKNOWN_FUNCTION;\n      }\n\n      if (stackInfo.stack.length > 0) {\n        if (stackInfo.stack[0].url === initial.url) {\n          if (stackInfo.stack[0].line === initial.line) {\n            return false; // already in stack trace\n          } else if (\n            !stackInfo.stack[0].line &&\n            stackInfo.stack[0].func === initial.func\n          ) {\n            stackInfo.stack[0].line = initial.line;\n            return false;\n          }\n        }\n      }\n\n      stackInfo.stack.unshift(initial);\n      stackInfo.partial = true;\n      return true;\n    } else {\n      stackInfo.incomplete = true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Computes stack trace information by walking the arguments.caller\n   * chain at the time the exception occurred. This will cause earlier\n   * frames to be missed but is the only way to get any stack trace in\n   * Safari and IE. The top frame is restored by\n   * {@link augmentStackTraceWithInitialElement}.\n   * @param {Error} ex\n   * @return {?Object.<string, *>} Stack trace information.\n   */\n  function computeStackTraceByWalkingCallerChain(ex, depth) {\n    var functionName = /function\\s+([_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*)?\\s*\\(/i,\n      stack = [],\n      funcs = {},\n      recursion = false,\n      parts,\n      item,\n      source;\n\n    for (\n      var curr = computeStackTraceByWalkingCallerChain.caller;\n      curr && !recursion;\n      curr = curr.caller\n    ) {\n      if (curr === computeStackTrace || curr === TraceKit.report) {\n        // console.log('skipping internal function');\n        continue;\n      }\n\n      item = {\n        url: null,\n        func: UNKNOWN_FUNCTION,\n        line: null,\n        column: null\n      };\n\n      if (curr.name) {\n        item.func = curr.name;\n      } else if ((parts = functionName.exec(curr.toString()))) {\n        item.func = parts[1];\n      }\n\n      if (typeof item.func === 'undefined') {\n        try {\n          item.func = parts.input.substring(0, parts.input.indexOf('{'));\n        } catch (e) {}\n      }\n\n      if (funcs['' + curr]) {\n        recursion = true;\n      } else {\n        funcs['' + curr] = true;\n      }\n\n      stack.push(item);\n    }\n\n    if (depth) {\n      // console.log('depth is ' + depth);\n      // console.log('stack is ' + stack.length);\n      stack.splice(0, depth);\n    }\n\n    var result = {\n      name: ex.name,\n      message: ex.message,\n      url: getLocationHref(),\n      stack: stack\n    };\n    augmentStackTraceWithInitialElement(\n      result,\n      ex.sourceURL || ex.fileName,\n      ex.line || ex.lineNumber,\n      ex.message || ex.description\n    );\n    return result;\n  }\n\n  /**\n   * Computes a stack trace for an exception.\n   * @param {Error} ex\n   * @param {(string|number)=} depth\n   */\n  function computeStackTrace(ex, depth) {\n    var stack = null;\n    depth = depth == null ? 0 : +depth;\n\n    try {\n      stack = computeStackTraceFromStackProp(ex);\n      if (stack) {\n        return stack;\n      }\n    } catch (e) {\n      if (TraceKit.debug) {\n        throw e;\n      }\n    }\n\n    try {\n      stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);\n      if (stack) {\n        return stack;\n      }\n    } catch (e) {\n      if (TraceKit.debug) {\n        throw e;\n      }\n    }\n    return {\n      name: ex.name,\n      message: ex.message,\n      url: getLocationHref()\n    };\n  }\n\n  computeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;\n  computeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;\n\n  return computeStackTrace;\n})();\n\nmodule.exports = TraceKit;\n"],"mappings":"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6B,EAAE,EAAE;QACxBM,oBAAoB,CAAC,CAAC;MACxB;IACF,CAAC,EACDtB,KAAK,CAACsC,UAAU,GAAG,IAAI,GAAG,CAC5B,CAAC;IAED,IAAIH,OAAO,KAAK,KAAK,EAAE;MACrB,MAAMnB,EAAE,CAAC,CAAC;IACZ;EACF;EAEAjC,MAAM,CAACM,SAAS,GAAGA,SAAS;EAC5BN,MAAM,CAACU,WAAW,GAAGA,WAAW;EAChCV,MAAM,CAACwD,SAAS,GAAG1C,cAAc;EACjC,OAAOd,MAAM;AACf,CAAC,CAAE,CAAC;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACApB,QAAQ,CAACyD,iBAAiB,GAAI,SAASoB,wBAAwBA,CAAA,EAAG;EAChE;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,SAASC,8BAA8BA,CAACzB,EAAE,EAAE;IAC1C,IAAI,OAAOA,EAAE,CAAChB,KAAK,KAAK,WAAW,IAAI,CAACgB,EAAE,CAAChB,KAAK,EAAE;IAElD,IAAI0C,MAAM,GAAG,yIAAyI;IACtJ,IAAIC,KAAK,GAAG,uHAAuH;IACnI;IACA;IACA,IAAIC,KAAK,GAAG,wKAAwK;IACpL;IACA,IAAIC,SAAS,GAAG,+CAA+C;IAC/D,IAAIC,UAAU,GAAG,+BAA+B;IAChD,IAAIC,KAAK,GAAG/B,EAAE,CAAChB,KAAK,CAACgD,KAAK,CAAC,IAAI,CAAC;IAChC,IAAIhD,KAAK,GA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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}